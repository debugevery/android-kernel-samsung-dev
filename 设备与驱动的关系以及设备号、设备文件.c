设备与驱动的关系以及设备号、设备文件 (2009-09-28 12:36) 




这章将介绍Linux系统的设备，这样我们才能清楚的知道应用程序和设备驱动程序是如何的工作的，或者说应用程序是如何控制驱动程序的，进而知道应用程序是如何通过驱动程序操作设备的，另外会详细的介绍设备号及设备文件。

 

Linux设备分类
Linux下的设备通常分为三类，字符设备，块设备和网络设备。

字符设备 

一个字符设备是一种字节流设备，对设备的存取只能按顺序按字节的存取而不能随机访问，字符设备没有请求缓冲区，所有的访问请求都是按顺序执行的。Linux下的大多设备都是字符设备。应用程序是通过字符设备节点来访问字符设备的。设备节点一般都由mknod命令都创建在/dev目录下，下面的例子显示了串口设备的设备节点。字符设备文件的第一个标志是前面的“c”标志。

root#ls -l /dev/ttyS[0-3]
crw-rw----  1 root  root 4, 64 Feb 18 23:34 /dev/ttyS0
crw-r-----  1 root  root 4, 65 Nov 17 10:26 /dev/ttyS1
crw-rw----  1 root  root 4, 66 Jul  5  2000 /dev/ttyS2
crw-rw----  1 root  root 4, 67 Jul  5  2000 /dev/ttyS3
 

字符设备是指那些只能按顺序一个字节一个字节读取的设备，但事实上现在一些高级字符设备也可以从指定位置一次读取一块数据。字符设备是面向数据流的设备，每个字符设备都有一个设备号，设备号由主设备号和次设备号组成。同时Linux使用管理文件相同的方法来管理字符设备，所以每个字符设备在/dev/目录下都有一个对应的设备文件，即设备节点，它们包含了设备的类型、主/次设备号以及设备的访问权限控制等，系统通过设备文件来对字符设备进行操作，每个字符设备文件都有自己的与普通文件相同的文件操作函数组结构（struct file_operations）。字符设备驱动通常至少需要实现文件操作函数组中的open、release、read和write四种操作方法。常见的字符设备有鼠标、键盘、串口、控制台等。

块设备 

存储设备一般属于块设备，块设备有请求缓冲区，并且支持随机访问而不必按照顺序去存取数据，比如你可以先存取后面的数据，然后在存取前面的数据，这对字符设备来说是不可能的。Linux下的磁盘设备都是块设备，尽管在Linux下有块设备节点，但应用程序一般是通过文件系统及其高速缓存来访问块设备的,而不是直接通过设备节点来读写块设备上的数据。块设备文件的第一个标志是前面的“b”标志。

root# ls -l /dev/hda[1-3]
brw-rw----  1 root  root  3, 1 Jul  5  2000 /dev/hda1
brw-rw----  1 root  root  3, 2 Jul  5  2000 /dev/hda2
brw-rw----  1 root  root  3, 3 Jul  5  2000 /dev/hda3
 

块设备是指那些可以从设备的任意位置读取任意长度数据的设备。每个块设备同样有一个设备号，设备号由主设备号和次设备号组成。同时Linux也使用管理文件相同的方法来管理块设备，每个块设备在/dev/目录下都有一个对应的设备文件，即设备节点，它们包含了设备的类型、主/次设备号以及设备的访问权限控制等，系统通过设备文件来对块设备进行操作，每个块设备文件都有自己的与普通文件相同的文件操作函数组结构（struct file_operations）。但块设备需要实现的操作方法远比字符设备的操作方法多得多，也难得多。块设备既可以作为普通的裸设备用来存放任意数据，也可以将块设备按某种文件系统类型的格式进行格式化，然后按照该文件系统类型的格式来读取块设备上的数据，但不管哪种方式，最后访问设备上的数据都必须通过调用设备本身的操作方法实现，区别在于前者直接调用块设备的操作方法，而后者则间接调用块设备的操作方法。常见的块设备有各种硬盘、flash磁盘、RAM磁盘等。

网络设备 

网络设备不同于字符设备和块设备，它是面向报文的而不是面向流的，它不支持随机访问，也没有请求缓冲区。在Linux里一个网络设备也可以叫做一个网络接口，如eth0，应用程序是通过Socket而不是设备节点来访问网络设备，在系统里根本就不存在网络设备节点。

网络接口用来与其他设备交换数据，它可以是硬件设备，也可以是纯软件设备，如loopback接口就是一个纯软件设备。网络接口由内核中的网络子系统驱动，负责发送和接收数据包，但它不需要了解每项事务如何映射到实际传送的数据包，许多网络连接（尤其是使用TCP协议的连接）是面向流的，但网络设备围绕数据包的传输和接收设计。网络驱动程序不需要知道各个连接的相关信息，它只需处理数据包。网络接口没有像字符设备和块设备一样的设备号，只有一个唯一的名字，如eth0、eth1等，而这个名字也不需要与设备文件节点对应。内核使用一套与数据包传输相关的函数来与网络设备驱动程序通信，它们不同于字符设备和块设备的read()和write()方法。


设备节点、设备驱动及设备的关联
     当我们访问一个设备节点是，系统是如果知道使用哪个设备驱动及访问哪个设备的呢？这个是通过设备号来实现的。当我们创建一个设备节点时需要指定主设备号和次设备号。对于设备节点来说，名字不是重要的，设备号才是最重要的，它实际指定了对应的驱动程序和对应的设备。

Linux的设备管理是和文件系统紧密结合的，各种设备都以文件的形式存放在/dev目录下，称为设备文件。应用程序可以打开、关闭和读写这些设备文件，完成对设备的操作，就像操作普通的数据文件一样。为了管理这些设备，系统为设备编了号，每个设备号又分为主设备号和次设备号。主设备号用来区分不同种类的设备，而次设备号用来区分同一类型的多个设备。对于常用设备，Linux有约定俗成的编号，如硬盘的主设备号是3。 

 

      Linux为所有的设备文件都提供了统一的操作函数接口，方法是使用数据结构struct file_operations。这个数据结构中包括许多操作函数的指针，如open()、close()、read()和write()等，但由于外设的种类较多，操作方式各不相同。Struct file_operations结构体中的成员为一系列的接口函数，如用于读/写的read/write函数和用于控制的ioctl等。打开一个文件就是调用这个文件file_operations中的open操作。不同类型的文件有不同的file_operations成员函数，如普通的磁盘数据文件，接口函数完成磁盘数据块读写操作；而对于各种设备文件，则最终调用各自驱动程序中的I/O函数进行具体设备的操作。这样，应用程序根本不必考虑操作的是设备还是普通文件，可一律当作文件处理，具有非常清晰统一的I/O接口。所以file_operations是文件层次的I/O接口。

 

主设备号 

驱动程序在初始化时，会注册它的驱动及对应主设备号到系统中，这样当应用程序访问设备节点时，系统就知道它所访问的驱动程序了。你可以通过/proc/devices文件来驱动系统设备的主设备号。

次设备号 

驱动程序遍历设备时，每发现一个它能驱动的设备，就创建一个设备对象，并为其分配一个次设备号以区分不同的设备。这样当应用程序访问设备节点时驱动程序就可以根据次设备号知道它说访问的设备了。

系统中的每一个字符设备和块设备（网络接口没有设备号）都有一个设备号，传统的UNIX以及早期版本Linux中的设备号是16位的，主次设备号都是8位的，低8位为次设备号，高8位为主设备号，因此系统最多分别支持65536个字符设备和65536个块设备，这个限制已经不能满足当前层出不穷的各种新设备的需要，所以Linux2.6中对设备号已经进行了扩展，一个设备号为32位，主设备号为12位，次设备号为20位，但是这32位设备号的编码方式有新旧两种，旧的设备编号格式为：最高12位为主设备号，最低20位为次设备号；新的设备编号格式为：bit[19:8]是主设备号，bit[31:20]是次设备号的高12位，bit[7:0]是次设备号的低8位。如果知道了一个设备的主设备号major和次设备号minor，那么用MKDEV(major,minor)生成是该设备的旧格式的设备号，用new_encode_dev(MKDEV(major,minor))生成的则是新格式的设备号。Linux支持的各种设备的主设备号定义在include/linux/major.h文件中，而已经在官方注册的主设备号和次设备号在Documentation/devices.txt文件中可以找到。

老式16位设备号、32位旧格式设备号以及32位新格式设备号的转换操作函数如下：

new_encode_dev(dev_t dev)函数

将32位旧格式设备号dev转换成32位新格式设备号。

new_decode_dev(u32 dev)函数

将32位新格式设备号转换成32位旧格式设备号。

old_encode_dev(dev_t dev)函数

将32位旧格式设备号转换成老式16位设备号。

dev_t old_decode_dev(u16 val)函数

将老式16位设备号转换成32位旧格式设备号。

Linux中设备节点是通过“mknod”命令来创建的。一个设备节点其实就是一个文件，Linux中称为设备文件。有一点必要说明的是，在Linux中，所有的设备访问都是通过文件的方式，一般的数据文件程序普通文件，设备节点称为设备文件。在Linux内核中网络设备也是通过文件操作的，称为网络设备文件，在用户空间是通过socket接口来访问的。socket号就是网络设备文件描述符。

如：mknod /dev/mydevice c 254 0

(c代表子都设备，254为主设备号，0为次设备号)

Open，close等操作/dev/下设备文件，内核根据文件的主设备号找到对应的设备驱动

主设备号可以分为动态和静态申请。

设备文件

Linux使用对文件一样管理方式来管理设备，所以对于系统中的每个字符设备或者块设备都必须为其创建一个设备文件，这个设备文件就是放在/dev/目录下的设备节点，它包含了该设备的设备类型（块设备或字符设备）、设备号（主设备号和次设备号）以及设备访问控制属性等。设备文件可以通过手工用mknod命令生成也可以由udev用户工具软件在系统启动后根据/sys目录下每个设备的实际信息创建，使用后一种方式可以为每个设备动态分配设备号，而不必分配固定的设备号，如果系统中的设备不多，而且设备类型又是常见的，可以使用手工方式生成设备文件，为常用设备创建一个已经分配号的设备号对应的设备文件，这样比较方便。如果系统很大，系统中的设备太多，那么最好动态分配设备号，由udev在系统启动之后根据设备实际信息自动创建设备文件。

